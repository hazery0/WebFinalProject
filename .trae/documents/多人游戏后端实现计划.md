# 多人游戏后端实现计划

## 1. 需求分析

基于前端已实现的多人游戏功能，后端需要支持：
- 房间管理（创建、加入、离开、查询）
- 玩家管理（添加、状态更新、列表查询）
- 游戏状态管理（开始、结束、进行中）
- 实时通信（WebSocket）
- 游戏逻辑（随机人物生成、猜测验证、结果判断）

## 2. 技术选型

- **Spring Boot 3**：后端框架
- **Spring Data JPA**：数据库操作
- **WebSocket**：实时通信
- **MySQL**：数据存储
- **Redis**（可选）：用于存储房间和游戏状态（若需要）

## 3. 核心实体设计

### 3.1 GameRoom（游戏房间）
```java
@Entity
@Table(name = "game_rooms")
public class GameRoom {
    @Id
    private String roomId; // 4位房间号
    
    @Column(nullable = false)
    private LocalDateTime createTime;
    
    @Enumerated(EnumType.STRING)
    private GameStatus status; // WAITING, PLAYING, ENDED
    
    @OneToMany(mappedBy = "room", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    private List<GamePlayer> players;
    
    @OneToOne(cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    private HistoricalPerson targetPerson; // 当前游戏目标人物
    
    @Column(nullable = false, columnDefinition = "int default 2")
    private Integer maxPlayers = 2; // 最大玩家数
}
```

### 3.2 GamePlayer（游戏玩家）
```java
@Entity
@Table(name = "game_players")
public class GamePlayer {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(nullable = false)
    private String playerId; // 前端生成的玩家ID
    
    @Column(nullable = false)
    private String username;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "room_id", nullable = false)
    private GameRoom room;
    
    @Enumerated(EnumType.STRING)
    private PlayerStatus status; // READY, PLAYING, WINNER, LOSER
    
    @Column(columnDefinition = "int default 0")
    private Integer guessCount = 0; // 猜测次数
}
```

### 3.3 GameHistory（游戏历史）
```java
@Entity
@Table(name = "game_histories")
public class GameHistory {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(nullable = false)
    private String roomId;
    
    @Column(nullable = false)
    private LocalDateTime startTime;
    
    private LocalDateTime endTime;
    
    @OneToOne(fetch = FetchType.LAZY)
    private HistoricalPerson targetPerson;
    
    @Column(nullable = false)
    private String winnerId;
    
    private Integer totalGuessCount;
}
```

### 3.4 枚举类
```java
// 游戏状态
public enum GameStatus {
    WAITING, // 等待玩家加入
    PLAYING, // 游戏进行中
    ENDED    // 游戏结束
}

// 玩家状态
public enum PlayerStatus {
    READY,   // 准备就绪
    PLAYING, // 游戏中
    WINNER,  // 胜利者
    LOSER    // 失败者
}
```

## 4. 服务层设计

### 4.1 GameRoomService
- `createRoom()`：创建新房间
- `joinRoom(String roomId, String playerId, String username)`：加入房间
- `leaveRoom(String roomId, String playerId)`：离开房间
- `getRoomInfo(String roomId)`：获取房间信息
- `getRoomList()`：获取所有等待中的房间

### 4.2 GameService
- `startGame(String roomId)`：开始游戏
- `endGame(String roomId, String winnerId)`：结束游戏
- `guessPerson(String roomId, String playerId, Long personId)`：玩家猜测
- `getGameStatus(String roomId)`：获取游戏状态

### 4.3 GamePlayerService
- `addPlayer(String roomId, String playerId, String username)`：添加玩家
- `updatePlayerStatus(String roomId, String playerId, PlayerStatus status)`：更新玩家状态
- `getPlayersInRoom(String roomId)`：获取房间内所有玩家

## 5. WebSocket实现

### 5.1 WebSocket配置
```java
@Configuration
@EnableWebSocketMessageBroker
public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {
    // 配置WebSocket消息代理和端点
}
```

### 5.2 WebSocket控制器
```java
@Controller
public class GameWebSocketController {
    @MessageMapping("/game/join")
    @SendTo("/topic/game/{roomId}")
    public GameRoom joinRoom(JoinRequest request) {
        // 处理玩家加入逻辑
    }
    
    @MessageMapping("/game/guess")
    @SendTo("/topic/game/{roomId}")
    public GameStatus guessPerson(GuessRequest request) {
        // 处理玩家猜测逻辑
    }
    
    // 其他WebSocket消息处理方法
}
```

### 5.3 消息模型
- `JoinRequest`：玩家加入请求
- `GuessRequest`：玩家猜测请求
- `GameStatusUpdate`：游戏状态更新
- `PlayerStatusUpdate`：玩家状态更新

## 6. REST API设计

### 6.1 GameRoomController
- `POST /api/game/rooms`：创建房间
- `GET /api/game/rooms`：获取房间列表
- `GET /api/game/rooms/{roomId}`：获取房间详情
- `POST /api/game/rooms/{roomId}/join`：加入房间
- `POST /api/game/rooms/{roomId}/leave`：离开房间

### 6.2 GameController
- `POST /api/game/rooms/{roomId}/start`：开始游戏
- `POST /api/game/rooms/{roomId}/end`：结束游戏
- `POST /api/game/rooms/{roomId}/guess`：玩家猜测
- `GET /api/game/rooms/{roomId}/status`：获取游戏状态

## 7. 数据库配置

在`application.properties`中添加配置：
```properties
# WebSocket配置
spring.messaging.broker.enabled=true
spring.messaging.broker.simple.broker=/topic
spring.messaging.broker.simple.application-destination-prefix=/app
```

## 8. 实现步骤

1. **创建实体类**：GameRoom、GamePlayer、GameHistory及枚举类
2. **创建Repository接口**：GameRoomRepository、GamePlayerRepository、GameHistoryRepository
3. **创建服务层**：GameRoomService、GameService、GamePlayerService
4. **实现WebSocket配置**：WebSocketConfig
5. **实现WebSocket控制器**：GameWebSocketController
6. **实现REST API控制器**：GameRoomController、GameController
7. **更新SecurityConfig**：允许WebSocket和游戏相关API的访问
8. **测试和调试**：确保前后端能够正常通信

## 9. 关键技术点

- **WebSocket实时通信**：确保游戏状态和玩家信息能够实时更新
- **房间ID生成**：生成唯一的4位房间号
- **游戏逻辑实现**：结合现有的HistoricalPersonService实现游戏核心逻辑
- **并发处理**：确保多玩家同时操作时的数据一致性
- **状态管理**：清晰管理游戏和玩家的各种状态

## 10. 依赖添加

在`pom.xml`中添加WebSocket依赖：
```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-websocket</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-messaging</artifactId>
</dependency>
```